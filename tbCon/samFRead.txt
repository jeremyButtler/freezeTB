
  bytesReadInUL =
         fread(
            *buffStr,
            sizeof(char),
            *lenBuffUL - 1,
            samFILE
         ); /*Get the next part in the buffer*/
   curPosUL = ftell(samFILE);
   tmpStr = "1"; /*Just a quick blank value*/

   while(*tmpStr != '\n')
   { /*Loop: Find the length of  the line*/
      bytesReadInUL =
         fread(
            *buffStr,
            sizeof(char),
            *lenBuffUL - 1,
            samFILE
         ); /*Get the next part in the buffer*/

      if(! bytesReadInUL) break; /*End of file*/

      /*Add  null for fread*/
      (*buffStr)[bytesReadInUL] = '\0';
      ulStr = (ulong *) *buffStr;

      while(!
         ((   (*ulStr & ~ def_samEntry_newLine)
            - def_samEntry_one
          ) & def_samEntry_highBit
        )
      ) { /*Loop: Find the new line or null entry*/
         ++ulStr;
         lenLineL += defCharPerUL;
      } /*Loop find the new line or nulI*/

      /*Logic:
      ` This is a litter faster then ulCpStr's if check.
      `   This is due to this not having to worry about
      `   unintended results.
      `   - *ulStr & ~(0x0a0a0a...0a):
      `     o Converts new lines, start of text (STX, 2),
      `       and backspace (BS, 8) to 0
      `     o So I only have to worry about values not
      `       in a text file (STX and BS)
      `     o def_samEntry_newLine 0x0a0a0a...0a, were
      `       0x0a = '\n'. So, it is  long with every byte
      `       being a new line
      `   - (*ulStr & ~(0x0a0a0a...0a)) - 0x01010101...01
      `     o Converts 0 (newline or null) to -1
      `     o def_samEntry_one = 0x010101...01
      `   - (-1 or postive number) & 0x808080...80
      `     o Converts -1 to -127 (smallest char)
      `     o Converts any positive number to 0
      `     o def_samEntry_highBit = 0x808080...80
      */

      tmpStr = (char *) ulStr;

      while( (*tmpStr & ~'\n') )
      { /*Loop: Finish of the last few characters*/
         ++tmpStr;
         ++lenLineL;
      } /*Loop: Finish of the last few characters*/
   } /*Loop: Find the length of  the line*/
   
   if(! lenLineL) return 1; /*End of file*/

   /*Get back to the start of the read*/
   fseek(samFILE, curPosUL, SEEK_SET);
   lenLineL += 3; /*Account for newline and null*/

   if(*lenBuffUL < lenLineL)
   { /*If: I need a bigger buffer*/
      *lenBuffUL = lenLineL;
      free(*buffStr);
      *buffStr = malloc(lenLineL * sizeof(char));

      if(! *buffStr) return 64; /*memory error*/
   } /*If: I need a bigger buffer*/
      
   bytesReadInUL =
      fread(
         *buffStr,
         sizeof(char),
         lenLineL - 2,
         samFILE
      ); /*Get the next part in the buffer*/

   /*Add null in for fread*/
   (*buffStr)[bytesReadInUL - 1] = '\0';
   iterStr = *buffStr;

   /*Get back to the start of the read*/
   fseek(samFILE, curPosUL, SEEK_SET);
   lenLineL += 3; /*Account for newline and null*/

   if(*lenBuffUL < lenLineL)
   { /*If: I need a bigger buffer*/
      *lenBuffUL = lenLineL;
      free(*buffStr);
      *buffStr = malloc(lenLineL * sizeof(char));

      if(! *buffStr) return 64; /*memory error*/
   } /*If: I need a bigger buffer*/
      
   bytesReadInUL =
      fread(
         *buffStr,
         sizeof(char),
         lenLineL - 2,
         samFILE
      ); /*Get the next part in the buffer*/

   /*Add null in for fread*/
   (*buffStr)[bytesReadInUL - 1] = '\0';
   iterStr = *buffStr;
