# NOTE on linux you need a shared library ray lib install
#  this is because GL (-lGL) is often installed
#  as a shared library (no .a file)

CC=clang
LD=clang
MAKE=make
CFLAGS=-DNONE
coreCFLAGS=-DMAC -c -static -O0 -g -Wall -Wextra
O=linux
raylibPath=../raylib/src
genLib=../genLib
LDMacFlags=\
   -framework Foundation \
   -framework CoreVideo \
   -framework IOKit \
   -framework Cocoa \
  	-framework GLUT \
   -framework OpenGL \
   ../raylib/src/libraylib.a

# foundation is so I can detect dark and light mode in
#   widgets

objFiles=\
   $(genLib)/ulCp.$O \
   $(genLib)/base10str.$O \
   rayWidg.$O \
   ftbRayST.$O \
   ftbRay.$O

ftbRay: ftbRay.$O
		$(LD) $(LDMacFlags) -o ftbRay $(objFiles)
	# note, ray lib file should come last. Also, if
	# possible, use local location so the user does not
	# need to install raylib (may not be possible)

ftbRay.$O: ftbRay.c ftbRayST.$O
		$(CC) $(coreCFLAGS) $(CFLAGS) \
			-o ftbRay.$O  ftbRay.c

ftbRayST.$O: ftbRayST.c ftbRayST.h rayWidg.$O
		$(CC) $(coreCFLAGS) $(CFLAGS) -o ftbRayST.$O \
			ftbRayST.c

rayWidg.$O: rayWidg.c rayWidg.h \
	ulCp.$O base10str.$O $(libRayLib)
		$(CC) -I$(raylibPath) $(coreCFLAGS) $(CFLAGS) \
			-o rayWidg.$O \
			rayWidg.c

base10str.$O: $(genLib)/base10str.c $(genLib)/base10str.h
		$(CC) $(coreCFLAGS) $(CFLAGS) \
			-o $(genLib)/base10str.$O $(genLib)/base10str.c

ulCp.$O: $(genLib)/ulCp.c $(genLib)/ulCp.h
		$(CC) $(coreCFLAGS) $(CFLAGS) -o $(genLib)/ulCp.$O \
			$(genLib)/ulCp.c

# need to build raylib, but bit tricky
$(libRayLib): $(raylibPath)/raylib.h
	export MACOSX_DEPLOYMENT_TARGET=10.9 \
	xcode-select --install && \
	$(MAKE) PLATFORM=PLATFORM_DESKTOP -C ../raylib/src;

clean:
	objStr="$(objFiles)"; \
		fileStr="$${objStr%% *}"; \
		while [ ! "$$fileStr" = "" ]; \
		do \
			if [ -f "$$fileStr" ]; then rm "$$fileStr"; fi; \
			objStr="$${objStr#"$${objStr%%[[:space:]]*}"}"; \
			objStr="$${objStr#"$${objStr%%[![:space:]]*}"}";\
			objStr="$${objStr%% *}"; \
			fileStr="$${objStr%% *}"; \
		done;
	$(MAKE) -C ../raylib/src clean 
			# this clean up step is more complex, but it also
			# avoids trying to deleting files that do not
			# exist. So, it never errors out
